# Architectural Decision Records (ADR) – Weather App

## ADR-001: Використання Fastify як HTTP-сервера

**Дата:** 2025-06-07  
**Статус:** Прийнято  

**Контекст:**  
Потрібен легкий, продуктивний HTTP-сервер для побудови REST API.

**Рішення:**  
Обрано Fastify через:
- Високу продуктивність
- Просту інтеграцію з TypeScript
- Розвинуту систему плагінів
- Підтримку JSON Schema валідації на рівні маршруту

**Наслідки:**  
- Спрощене тестування і розширення
- Проста читабельність
- Використання плагінів Fastify замість звичних middleware

---

## ADR-002: Використання PostgreSQL як бази даних

**Дата:** 2025-06-07  
**Статус:** Прийнято  

**Контекст:**  
Потрібно зберігати підписки користувачів. У подальшому передбачаються чітки зв'язки між сутностями. Окрім цього важлива можливість роботи з транзакціями. 

**Рішення:**  
Використовуємо PostgreSQL:
- Реляційна БД підходить для структурованих зв’язків
- Підтримка транзакцій для оновлення взаємозалежних записів
- Доступні розширення для зручності масштабування
- Працює з Prisma ORM

**Наслідки:**  
- Необхідно слідкувати за міграціями
- Потенційно потребуватиме оптимізації при масштабуванні

---

## ADR-003: Використання Prisma як ORM

**Дата:** 2025-06-07  
**Статус:** Прийнято  

**Контекст:**  
Потрібна зручна ORM з автогенерацією типів і інтеграцією з TypeScript.

**Рішення:**  
Prisma:
- Швидке створення моделей і міграцій
- Автогенерація TS типів
- Простий синтаксис запитів

**Наслідки:**  
- Вимагає ручного оновлення схеми при зміні БД
- Важливо моніторити performance при складних join операціях

---

## ADR-004: Валідація через Zod

**Дата:** 2025-06-07  
**Статус:** Прийнято  

**Контекст:**  
Потрібна типобезпечна валідація запитів на вході.

**Рішення:**  
Використовуємо Zod:
- Сумісний з TypeScript
- Універсальне використання (HTTP, cron, email)
- Zod-схеми одночасно виступають як валідація і як джерело типів DTO

**Наслідки:**  
- Код може дублювати опис схеми Prisma
- Потрібно синхронізувати структури даних
- Просте тестування вхідних даних і передача типізованих DTO далі в бізнес-логіку

---

## ADR-005: Отримання погодних даних з OpenWeather API

**Дата:** 2025-06-07  
**Статус:** Прийнято  

**Контекст:**  
Потрібне надійне джерело погодних даних з прогнозом.

**Рішення:**  
- Обрали OpenWeather через гнучке API, доступність погодинного/щоденного прогнозу

**Наслідки:**  
- Залежність від стороннього сервісу
- Можливість керувати об'ємом даних, що надходить у відповіді API

---

## ADR-006: Розділення додатку на мікросервіси

**Дата:** 2025-07-08  
**Статус:** Прийнято  

**Контекст:**  
Додаток має кілька незалежних бізнес-логік, які можна винести в окремі мікросервіси для спрощення масштабування, підтримки та розробки. Також необхідно визначити оптимальний спосіб комунікації між сервісами.

**Рішення:**  
Виділяємо наступні мікросервіси:

1. **Weather Service**  
   - Відповідальність: Надання актуальної інформації про погоду.  
   - Компоненти:
     - Маршрути: `src/routes/weather/`
     - Бізнес-логіка: `src/business/services/weather/`
     - Логіка отримання даних: `src/business/lib/weather/`
     - Кешування: `src/business/lib/redis.ts`

2. **Subscription Service**  
   - Відповідальність: Управління підписками користувачів (створення, підтвердження, скасування).  
   - Компоненти:
     - Маршрути: `src/routes/subscription/`
     - Бізнес-логіка: `src/business/services/subscription/`
     - Репозиторій: `src/database/repositories/subscription/`
     - Модель даних: `Subscription` в `schema.prisma`

3. **Notification Service**  
   - Відповідальність: Надсилання емейлів.  
   - Компоненти:
     - Логіка відправки: `src/business/lib/emails/`

4. **API Gateway**  
   - Відповідальність: Єдина точка входу для клієнтських запитів.  
   - Компоненти:
     - Конфігурація маршрутів: `src/routes/index.ts`
     - Обробка помилок: `src/plugins/error-handler.ts`
     - Health check та метрики: `src/routes/healthcheck/`, `src/routes/metrics/`

**Комунікація між сервісами:**  
1. **REST API (синхронна комунікація)**  
   - **Плюси:**  
     - Простота реалізації та інтеграції.  
     - Широка підтримка у всіх мовах програмування.  
     - Легко тестується через HTTP-запити.  
   - **Мінуси:**  
     - Висока затримка через HTTP-протокол.  
     - Немає вбудованої підтримки типів (потрібно додатково використовувати OpenAPI/Swagger).  
     - Менш ефективно для високонавантажених систем.

2. **Message Broker (асинхронна комунікація)**  
   - **Плюси:**  
     - Висока надійність: повідомлення зберігаються у черзі до обробки.  
     - Масштабованість: легко додати нові споживачі.  
     - Слабка зв'язаність між сервісами.  
   - **Мінуси:**  
     - Складність налаштування та підтримки брокера (RabbitMQ, Kafka).  
     - Затримка у доставці повідомлень.  
     - Ускладнення логіки обробки помилок.  

3. **gRPC (синхронна комунікація)**  
   - **Плюси:**  
     - Висока продуктивність завдяки використанню HTTP/2.  
     - Вбудована підтримка типів через Protocol Buffers.  
     - Підтримка потокової передачі даних (streaming).  
   - **Мінуси:**  
     - Складність налаштування порівняно з REST API.  
     - Менша підтримка у мовах програмування порівняно з REST.  
     - Потрібно генерувати код клієнта та сервера.  


**Рішення:**  
Вибираємо **gRPC** як основний спосіб комунікації між мікросервісами.  

**Причини:**  
- Висока продуктивність та низька затримка.  
- Типобезпечність завдяки Protocol Buffers.  
- Підтримка потокової передачі даних, що може бути корисним для майбутніх функцій.  

**Наслідки:**  
- Потрібно налаштувати генерацію кодів для клієнта та сервера.  
- Додаткове навчання команди для роботи з gRPC.  
- Залежність від HTTP/2 для коректної роботи.  